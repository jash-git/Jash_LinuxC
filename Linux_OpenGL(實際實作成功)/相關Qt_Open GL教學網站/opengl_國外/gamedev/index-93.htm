<!DOCTYPE html 
     PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
     "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"
    dir="ltr"
    xml:lang="en"
    lang="en">
  <head>
    <title>NeHe Productions: Handy Compilation of C/C++ Methods </title>

    <link rel="stylesheet" type="text/css" href="public_base.css" tppabs="http://nehe.gamedev.net/static/css/public_base.css" />
    <link type="text/css" rel="stylesheet" href="shThemeMidnight.css" tppabs="http://nehe.gamedev.net/static/css/syntax_highlighter/shThemeMidnight.css"/>
    
    <link rel="alternate" type="application/atom+xml" title="Atom feed" href="index-1.htm" tppabs="http://nehe.gamedev.net/atom/" />
    <link rel="alternate" type="application/rss+xml" title="RSS feed" href="index-2.htm" tppabs="http://nehe.gamedev.net/rss/" />
    
    <meta name="author" content="Luke Benstead + Carsten Haubold" />
    <meta name="description" content="OpenGL Tutorials, Demos, Games and More..." />
    <meta name="keywords" content="opengl, tutorial, article, demo, game, blend, texturemap, lighting, contest, 3D" />

    
    

    

</script>


    
    
    
    
        
        <script type='text/javascript'>
        var googletag = googletag || {};
        googletag.cmd = googletag.cmd || [];
        (function() {
        var gads = document.createElement('script');
        gads.async = true;
        gads.type = 'text/javascript';
        var useSSL = 'https:' == document.location.protocol;
        gads.src = (useSSL ? 'https:' : 'http:') + 
        '//www.googletagservices.com/tag/js/gpt.js';
        var node = document.getElementsByTagName('script')[0];
        node.parentNode.insertBefore(gads, node);
        })();
        </script>

        <script type='text/javascript'>
        googletag.cmd.push(function() {
        googletag.defineSlot('/1004699/Leaderboard_NeHe', [728, 90], 'div-gpt-ad-1327940144417-0').addService(googletag.pubads());
        googletag.defineSlot('/1004699/Skyscraper_NeHe', [160, 600], 'div-gpt-ad-1327940144417-1').addService(googletag.pubads());
        googletag.pubads().enableSingleRequest();
        googletag.enableServices();
        });
        </script>
    
    

    
  </head>

  <body>
    
<div id="fb-root"></div>
<script>(function(d, s, id) {
  var js, fjs = d.getElementsByTagName(s)[0];
  if (d.getElementById(id)) return;
  js = d.createElement(s); js.id = id;
  js.src = "all.js#xfbml=1"/*tpa=http://connect.facebook.net/en_GB/all.js#xfbml=1*/;
  fjs.parentNode.insertBefore(js, fjs);
}(document, 'script', 'facebook-jssdk'));</script>




    <table cellpadding="0" cellspacing="0" border="0" id="layout_table">
    <tr><td>
        <div id="header">
                <a href="index.htm" tppabs="http://nehe.gamedev.net/"><img class="logo" class="logo" src="nehe.png" tppabs="http://nehe.gamedev.net/static/images/nehe.png" border="0" alt="Nehe" /></a>
        </div>            
    </td></tr>
    <tr><td colspan="2">
            
<div class="navbar">
    <a href="index.htm" tppabs="http://nehe.gamedev.net/">HOME</a>
    <a href="javascript:if(confirm('http://twitter.com/  \n\nThis file was not retrieved by Teleport Pro, because it is addressed on a domain or path outside the boundaries set for its Starting Address.  \n\nDo you want to open it from the server?'))window.location='http://twitter.com/#!/nehegl'" tppabs="http://twitter.com/#!/nehegl">TWITTER</a>  
    <a href="javascript:if(confirm('http://www.facebook.com/pages/NeHe/300582493323181  \n\nThis file was not retrieved by Teleport Pro, because it is addressed on a domain or path outside the boundaries set for its Starting Address.  \n\nDo you want to open it from the server?'))window.location='http://www.facebook.com/pages/NeHe/300582493323181'" tppabs="http://www.facebook.com/pages/NeHe/300582493323181">FACEBOOK</a>     
    <a href="index-2.htm" tppabs="http://nehe.gamedev.net/rss/">RSS</a>    
    <a href="index-1.htm" tppabs="http://nehe.gamedev.net/atom/">ATOM</a>    
    <a href="javascript:if(confirm('http://www.gamedev.net/forum/27-nehe-productions/page__forum_title__NeHe+Productions  \n\nThis file was not retrieved by Teleport Pro, because it is addressed on a domain or path outside the boundaries set for its Starting Address.  \n\nDo you want to open it from the server?'))window.location='http://www.gamedev.net/forum/27-nehe-productions/page__forum_title__NeHe+Productions'" tppabs="http://www.gamedev.net/forum/27-nehe-productions/page__forum_title__NeHe+Productions">FORUM</a>    
</div>
    
    </td></tr>
    <tr>
        <td class="col1">

            
<div id="article_container">


<h1 class="article-header">Handy Compilation of C/C++ Methods </h1>
<div class="social-media">
<!-- Place this tag where you want the +1 button to render -->
<div class="g-plusone" data-size="medium" data-width="120" data-annotation="inline"></div>
<div class="fb-like" data-send="false" data-layout="button_count" data-width="60" data-show-faces="false" data-colorscheme="dark" data-font="arial"></div>
</div>
<div style="clear:both;"></div>
<p>&nbsp;<span style="text-decoration: underline;"><strong>Introduction</strong></span></p>
<p><br /> C++ is a very expansive language with many cool features that most people don't know- that is, until now! This collection of articles is designed to teach you, the adept C/C++ programmer, the tips and tricks of C and how you too can exploit them in your daily programming. Some of the methods will range from the commonly known yet under-used macros, to the incredible expandability of inheritance, to the utter power of memory functions. Much of it will surprise you with how easy it is to implement, so read on!</p>
<!-- break --><center><span style="text-decoration: underline;"><strong><span>About The Author</span></strong></span></center>
<p><br /> I am Paul Frazee, amateur programmer and computer game die-hard. I am fifteen years old and wrote most of these articles in, yes, the basement of my parent's house. I have been involved any many small projects, and hope to release a commercial game some day. I use a very laid-back writing style, to make things informative but fun to read too! I hope you enjoy it!</p>
<p>You can email me at <a href="mailto:paulfrazee@cox.net">paulfrazee@cox.net</a> with your questions, comments, and corrections. Don't hesitate to contact me; I enjoy the feedback!</p>
<center><span style="font-size: xx-small;">Update (07/21/03):</span></center>
<p><br /> Looking back at this article, I realize there were a lot of silly mistakes and some down-right misinformation, and all with my name on it. I apologize for not fixing them earlier, but now I have set all of that right. I am tempted to delete the above paragraph (*sigh*), but I will leave it there just for old-times sake. Note also that my email has changed. Code on!</p>
<p><strong><span style="text-decoration: underline;">Macros:</span></strong></p>
<p>Macros have to be the most under-used feature for new programmers. They are very useful, and a good programmer should take note of them. Why? Well, for instance, you can streamline a function that will be called often and with congruent parameters. The windows API call MessageBox is a good example:</p>
<pre class="brush: cpp; fontsize: 100; first-line: 1;">#define MSGBOX(body,title) MessageBox(NULL,body,title,MB_OK);
</pre>
<p>Now all you have to do is call MSGBOX("","") instead of MessageBox(NULL,"","",MB_OK)! Nice, huh?</p>
<p>Another common use is to define a standard function prototype that can be reproduced in an easy and clean way. For example, let's say you want to make a standard naming convention for a library you are making:</p>
<pre class="brush: cpp; fontsize: 100; first-line: 1;">#define FUNC(name) void FUNC_name(void)
</pre>
<p>Now you can easily declare and define a function that has FUNC_ at the front of the name, and is of type void. Observe:</p>
<pre class="brush: cpp; fontsize: 100; first-line: 1;">	FUNC(myfunc);						// Declaration
	...
	FUNC(myfunc)						// Definition
	{
		printf("MyFunc!!\n");
	}
	...
	void main()
	{
		FUNC_myfunc();					// Calling
	}
</pre>
<p>The output of that program would be "MyFunc!!" Cool, huh? Now that you have seen the wonders of macros, let's get a more in-depth look at them.</p>
<p><strong><span style="text-decoration: underline;">What Are Macros?</span></strong></p>
<p>Macros are, simply, groupings of code with a name attached. Like functions, they can have parameters passed to them, but it is important to note that they are not the same as functions. Functions are code compiled into a static memory location whose definition will appear in the actual binary output only once. Macros are, during early compilation stages, replace with the code they are defined as. Macros are pretty much always in all caps (by convention rather than necessity). You declare and define them all at once, and it is safe to define them in headers. Here is the format:</p>
<pre class="brush: cpp; fontsize: 100; first-line: 1;">#define()</pre>
<pre class="brush: cpp; fontsize: 100; first-line: 1;"></pre>
<p>You do not have to surround the contents with brackets ({}), although there are certain exceptions. If you ever wish to continue a macro past its declaration line, you append that line with a back-slash (\):</p>
<pre class="brush: cpp; fontsize: 100; first-line: 1;">	#define MyMacro(parameter) line 1 \
                                   line 2 \
                                   ... \
                                   line N
</pre>
<p>Another interesting feature is that the parameters are not type based, either. You can pass an integer, a string, or even flat out code to parameter. As long as you keep in mind what a macro truly is, you be able to use it effectively.</p>
<p>In case you are having trouble grasping this whole concept, I will provide you with an example. Observe:</p>
<pre class="brush: cpp; fontsize: 100; first-line: 1;">	#define MyMacro(text) printf(text);
</pre>
<p>As you can see, MyMacro is a macro that wraps the function printf. So...</p>
<pre class="brush: cpp; fontsize: 100; first-line: 1;">	void main()
	{
		MyMacro("Hello World!\n");
	}
</pre>
<p>is the exact same as saying</p>
<pre class="brush: cpp; fontsize: 100; first-line: 1;">	void main()
	{
		printf("Hello World!\n");
	}
</pre>
<p>Got it? Good. And remember, macros are not magical ways around casts. In the previous example, the data passed to MyMacro would have to be a string (char array).</p>
<p><strong><span style="text-decoration: underline;">When Should Macros Be Used?</span></strong></p>
<p>By now you may be asking yourself why one would ever really want to use a macro, especially when a function can do exactly the same thing. Well what you should understand about the macro is that it is designed simply for code cleanliness, a tool for the programmer. In the end product, it is no different from just typing out the body of the macro. So when is best? I recommend using it in the following situations:</p>
<ul>
<ul>1. When you have a common calculation or small code snippet that isnt worthy of a whole function. I especially recommend this for situations where you want to save on speed, since a function call just adds unnecessary operations (but that is serious operation-crunching). I find macros to be especially good for calculations, since the data cast is fairly inconsequential, where in a function you would have to either change the cast or write a version for each type.</ul>
</ul>
<p>&nbsp;</p>
<ul>
<ul>2. When you have common code that must be inserted to the calling position, such as common variable declaration.</ul>
</ul>
<p>&nbsp;</p>
<ul>
<ul>3. When you are enforcing a syntax standard, such as in a library.</ul>
</ul>
<p>&nbsp;</p>
<ul>4. One word  obfuscation.</ul>
<p>Use well.</p>
<p><strong><span style="text-decoration: underline;">This Pointer:</span></strong></p>
<p>The "this" pointer is so important that I cant imagine you dont already know of it. When programming data structures  usually classes - it may become necessary to refer to the instance of class within itself. The answer to this problem is the "this" pointer. It is a pointer of the type of the class it is being used in, to the instance using it. Behold:</p>
<pre class="brush: cpp; fontsize: 100; first-line: 1;">	class CMyClass
	{
	
		int int_variable;
		void MyFunction( int int_variable );
	
	};

	void CMyClass::MyFunction(int int_variable)
	{
		this-&gt;int_variable = int_variable;
	}
</pre>
<p>In this example, the programmer with horrible naming conventions had an ambiguous variable situation. The rules of C/C++ state that a parameter or locally defined variable overtakes a class member or global variable, which made access to CMyClass::int_variable impossible. To specify which variable he was talking about, the programmer used the this pointer. Another common use is to pass itself into a function, like in the following example:</p>
<pre class="brush: cpp; fontsize: 100; first-line: 1;">	void AddToInteger(CMyClass *MyClassInstance, int value)
	{
		MyClassInstance-&gt;int_variable += value;		// This Function Adds To
								// The Class' Variable
	}
	...
	void CMyClass::MyFunction(int int_variable)
	{
		AddToInteger(this,int_variable);		// We Pass This For The Class parameter
	}
</pre>
<p>Aha, very useful indeed! Note that the this pointer works just as well for structs.</p>
<p><strong><span style="text-decoration: underline;">Dynamic Memory:</span></strong></p>
<p>As you create more complex programs, you will find that arrays of a fixed size are not cutting it anymore. Eventually you are going to need to create arrays of variable size, allocate and delete objects, and more, and I can tell you how. But first, lets have a little technical stuff. This may be over your head  if it is, simply skip it. I would, however, recommend reading it; it is quite interesting.</p>
<p>First of all, you must understand that the program, when compiled, translates into memory positions in the executable (all of my discussion pertains to the PE executable file format common to Windows, though can apply in other situations). When the program is loaded into the memory, those memory positions remain intact, but are simply relative to the position the program was loaded into. So if a line of code was in position 4 in the executable file, and the file was loaded into position 1000 in the memory, that line of code would be at position 1004 in the memory.</p>
<p>Now, how are variables put into the memory? Well, that depends on the variables declaration situation. If a variable is global, it is actually put into the executable the same way code is, meaning that a 4 byte integer at position 20 would take up the positions 20 through 23 in the exe memory. That is why global variables are generally frowned upon  they make the executable take up more memory. Now, function-local, fixed-size variables (the ones you are used to) are different. They are allocated to what is called the "stack" at the beginning of a function call. The problem with those is that, as I previously mentioned, they are fixed-sized! The alternative is a dynamically allocated variable, which is managed through pointers.</p>
<p>Dynamically allocated variables are pointers that, instead of pointing to fixed-size variables in the memory, point to allocated memory in the "heap". Because these variables are not allocated until instructed to do so, and because the memory is managed by a flexible pointer, the programmer has the power to decide exactly how much memory the variable will need and when to allocate it. What this means for you is that you can create arrays of a size determined at runtime. I find the most common application to be with strings. Time to find out how this can be done!</p>
<p><strong><span style="text-decoration: underline;">Make Me Some Memory</span></strong></p>
<p>There are actually a couple ways to allocate memory in C++. The most common is new and delete, the C++ commands. New allocates the specified amount of memory and returns a pointer to it, and delete deallocates it. You should never use one without the other for stability reasons. Allocate with new but forget to free up with delete? You have what is called a memory leak  memory is being taken and not given back. Try to deallocate with delete but never allocated with a new? You program is going to crash through an assertion, because you just tried to deallocate "bogus" or null memory. The functions usages are as follows:</p>
<pre class="brush: cpp; fontsize: 100; first-line: 1;">	new &lt;data cast&gt;( &lt;parameters&gt; ); 			// Returns An Instance Of An Object
	delete &lt;variable&gt;;					// Deletes An Instance Of An Object
	new &lt;data cast&gt;[&lt;array element count&gt;];			// Returns An Array
	delete [] &lt;variable&gt;;					// Deletes An Array
</pre>
<p>The first two usages have to do with classes, and I will not delve into that any further. However, the latter two I will go into. You use those to create dynamic arrays  they are very simple. Here is an example:</p>
<pre class="brush: cpp; fontsize: 100; first-line: 1;">	int *intarray=NULL;					// Create A Null Pointer Of Type Int
	intarray = new int[50];					// Allocate An Array Of 50 Slots
	...
	if(intarray)						// Always Check To Make Sure It Exists To Avoid Crashes

	delete [] intarray;					// Delete Intarray
	intarray = NULL;					// Delete Does Not Set To Null, So It Is Best We Do
</pre>
<p>I recommend adhering to the example above pretty closely for allocation and deallocation, as failure to do so can very well lead to bugs.</p>
<p>The other way to allocate and deallocate memory is through the three functions left over from the C days: malloc, realloc, and free. How are they different? Well mostly in usage. New simplifies the allocation by calculating how much memory will be required and casting it for you (it multiplies the size of the type times the number of elements in the array). Malloc requires you to do all of that. So why use malloc and free? Personal preference, really. Here is the usage:</p>
<pre class="brush: cpp; fontsize: 100; first-line: 1;">	malloc( &lt;bytes&gt; );					// Allocate specified bytes
	free( &lt;variable&gt; );					// Deallocate variable memory
</pre>
<p>Malloc, free, and realloc all make use of the void pointer (a cast-less pointer). As such, you must cast the data, like so:</p>
<pre class="brush: cpp; fontsize: 100; first-line: 1;">	int* pData = (int *)malloc( sizeof( int ) * 100 );	// Allocates an integer array of 100 elements
	
	if( pData )
		free( pData );					// Deallocate pData
	pData = NULL;						// Free does not set to null, so we should
</pre>
<p>Malloc may look very intimidating, but it really isnt as complex as it looks. In the end, however, I recommend using new/delete, for a few reasons. First of all, when you are instantiating data objects with constructors or destroying those with destructors (not covered in this article), the constructor or destructor will be called. The other reason is that since you are probably writing in C++, then you will want to stick to the C++ commands.</p>
<p>Ah, one little function left  realloc. There will be times when you will want to resize your dynamic arrays. When this is the case, I would recommend using STLs vector or something along those lines, but I am betting that you dont know STL yet. So, we better reallocate that array! While you could just make a new array of the desired size, copy the old arrays data, and delete the old array, it is much easier to just use realloc:</p>
<pre class="brush: cpp; fontsize: 100; first-line: 1;">	realloc( &lt;variable&gt;, &lt;new_size&gt; );
</pre>
<p>Realloc returns the newly allocated data as a void pointer, and also takes the variable as a void pointer, requiring some casting on your part:</p>
<pre class="brush: cpp; fontsize: 100; first-line: 1;">	pData = (int *)realloc( (void *)pData, sizeof( int ) * 1000 );
</pre>
<p>That isnt so hard! And now you too can make dynamic arrays.</p>
<p>One final subject I should like to touch upon. You may be asking yourself whether it is safe to mix new/delete and malloc/realloc/free. The truth is that yes, it is completely safe. Data is data, no matter which function was used to attain it. However, it is considered to be good coding not to mix them. Now that you understand dynamic arrays, go grab yourself a book on STL and forget most of this! :D</p>
<p><strong><span style="text-decoration: underline;">Logic Without The If( ):</span></strong></p>
<p>Standard programming languages today are built on logic. And while if statements are all good, sometimes you just need a quick expression check that doesn't require all those brackets... and so the ? was born. ? is an expression evaluator, like the if statement but designed to work as a one-liner. Here is the syntax:</p>
<pre class="brush: cpp; fontsize: 100; first-line: 1;">	&lt;expression&gt; ? &lt;true return&gt; : &lt;false return&gt;
</pre>
<p>That may take a little explaining.is the logic in question (e.g. a==0 or handle!=NULL).is the code that will be executed if the expression evaluates to true.is the code that will be executed from the operator if the expression evaluates to false. If you are still stumped, consider this:</p>
<pre class="brush: cpp; fontsize: 100; first-line: 1;">	int a = 6;
	int value = (a==6) ? 3 : 6;
	printf("a=%d value=%d",value);
</pre>
<p>The output would be "a=6 value=3", because the expression (a==6) was true. You can also run functions instead of just returning a variable, like in this example:</p>
<pre class="brush: cpp; fontsize: 100; first-line: 1;">	int a = rand( )%2;					// Get A Random Number (0 or 1)
	a==1 ? printf("Random Returned 1!\n") : printf("Random Returned 0!\n");
</pre>
<p>How does that work? Well remember how macros would simply insert its code where it was used? This is kind of like a conditional macro that has its contents inserted at runtime. So if the condition evaluates to true, it is just like the true code was there, and the same for the false code when false. I find this particularly useful for when you are passing parameters or doing conditional math.</p>
<p><strong><span style="text-decoration: underline;">Getting That Log, Even In A Crash:</span></strong></p>
<p>When you start to make a complex system, especially a game, you need to have a logging system so that you can find out exactly what made your game crash. Unfortunately, those that have made them are certain to have experienced the log-destroying crash. An undefeatable problem? I think not.</p>
<p>What is happening when you lose your log? Well that has to do with the way file input/output works in C/C++. When you use file writing functions, the data is not immediately written, but rather qued for writing in the memory. The actual file writing will not occur until either the file is closed or until the file is flushed. When the program crashes, the data that was qued was never written  it was still in the memory. So as a good rule of thumb, when you write to a log, flush it immediately thereafter. If you are using the stdio FILE operations, you do that with fflush:</p>
<pre class="brush: cpp; fontsize: 100; first-line: 1;">fflush( &lt;FILE handle&gt; );					// Flushes output
</pre>
<p>Thats all it takes! No more lost logs! Yay!</p>
<p>Whelp, that concludes the article. Hope you learned something!</p>
<p>Paul Frazee (The Rainmaker)</p>


</div>
</div>



            <div style="width:728px;padding:0px;margin:auto; margin-top: 10px;">
            

    
                <!-- Leaderboard_NeHe -->
                <div id='div-gpt-ad-1327940144417-0' style='width:728px; height:90px;'>
                <script type='text/javascript'>
                googletag.cmd.push(function() { googletag.display('div-gpt-ad-1327940144417-0'); });
                </script>
                </div>
            

                           
            </div>   
        </td>
        <td class="col2">
            




<div style="text-align: center; padding:10px;">

<script type='text/javascript'>
    GA_googleFillSlot("Skyscraper_NeHe");
</script>

</div>
            
        </td>
    </table>
    <div id="footer">
        <p>
            
    
    © 1997-2012 Gamedev . All rights reserved.<br/>

			NeHe™ and NeHe Productions™ are trademarks of GameDev.net, LLC<br/>
			OpenGL® is a registered trademark of Silicon Graphics Inc.<br/>
		</p>        
		<br/>
    </div>

    
    
	    <script type="text/javascript" src="shCore.js" tppabs="http://nehe.gamedev.net/static/js/syntax_highlighter/shCore.js"></script>
        <script type="text/javascript" src="shBrushCpp.js" tppabs="http://nehe.gamedev.net/static/js/syntax_highlighter/shBrushCpp.js"></script>
	    <script type="text/javascript" src="shBrushJScript.js" tppabs="http://nehe.gamedev.net/static/js/syntax_highlighter/shBrushJScript.js"></script>
	    <script type="text/javascript">SyntaxHighlighter.all();</script>
    

    <!-- Place this render call where appropriate -->
    <script type="text/javascript">
      (function() {
        var po = document.createElement('script'); po.type = 'text/javascript'; po.async = true;
        po.src = 'plusone.js'/*tpa=https://apis.google.com/js/plusone.js*/;
        var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(po, s);
      })();
    </script>    

    
<!-- GoogleAnalytics code -->
<script src="urchin.js" tppabs="http://www.google-analytics.com/urchin.js" type="text/javascript">
</script>
<script type="text/javascript">
_uacct = "UA-279474-2"; // Gamedev
urchinTracker();
_uff = 0; // Reset for second account
_uacct = "UA-24180731-1"; // Non-GD
urchinTracker();
</script> 
  </body>
</html>
