<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8" /><title>2. Unicode和UTF-8</title><link rel="stylesheet" href="styles.css" tppabs="http://resource.lancetw.org/ebook/linux-c-on-site-learning-zh-tw/styles.css" type="text/css" /><meta name="generator" content="DocBook XSL Stylesheets V1.73.2" /><link rel="start" href="index.html" tppabs="http://resource.lancetw.org/ebook/linux-c-on-site-learning-zh-tw/index.html" title="Linux C編程一站式學習" /><link rel="up" href="apa.html" tppabs="http://resource.lancetw.org/ebook/linux-c-on-site-learning-zh-tw/apa.html" title="附錄 A. 字符編碼" /><link rel="prev" href="apas01.html" tppabs="http://resource.lancetw.org/ebook/linux-c-on-site-learning-zh-tw/apas01.html" title="1. ASCII碼" /><link rel="next" href="apas03.html" tppabs="http://resource.lancetw.org/ebook/linux-c-on-site-learning-zh-tw/apas03.html" title="3. 在Linux C編程中使用Unicode和UTF-8" /></head><body><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">2. Unicode和UTF-8</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="apas01.html" tppabs="http://resource.lancetw.org/ebook/linux-c-on-site-learning-zh-tw/apas01.html">上一頁</a> </td><th width="60%" align="center">附錄 A. 字符編碼</th><td width="20%" align="right"> <a accesskey="n" href="apas03.html" tppabs="http://resource.lancetw.org/ebook/linux-c-on-site-learning-zh-tw/apas03.html">下一頁</a></td></tr></table><hr /></div><div class="sect1" lang="zh-cn" xml:lang="zh-cn"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="id2906489"></a>2. Unicode和UTF-8</h2></div></div></div><p>為了統一全世界各國語言文字和專業領域符號（例如數學符號、樂譜符號）的編碼，ISO制定了ISO 10646<a id="id2906502" class="indexterm"></a>標準，也稱為UCS（Universal Character Set）<a id="id2906510" class="indexterm"></a>。UCS編碼的長度是31位，可以表示2<sup>31</sup>個字符。如果兩個字符編碼的高位相同，只有低16位不同，則它們屬於一個平面（Plane）<a id="id2906524" class="indexterm"></a>，所以一個平面由2<sup>16</sup>個字符組成。目前常用的大部分字符都位於第一個平面（編碼範圍是U-00000000~U-0000FFFD），稱為BMP（Basic Multilingual Plane）<a id="id2906537" class="indexterm"></a>或Plane 0，為了向後兼容，其中編號為0~256的字符和Latin-1相同。UCS編碼通常用U-xxxxxxxx這種形式表示，而BMP的編碼通常用U+xxxx這種形式表示，其中x是十六進制數字。在ISO制定UCS的同時，另一個由廠商聯合組織也在著手制定這樣的編碼，稱為Unicode<a id="id2906555" class="indexterm"></a>，後來兩家聯手制定統一的編碼，但各自發佈各自的標準文檔，所以UCS編碼和Unicode碼是相同的。</p><p>有了字符編碼，另一個問題就是這樣的編碼在計算機中怎麼表示。現在已經不可能用一個字節表示一個字符了，最直接的想法就是用四個字節表示一個字符，這種表示方法稱為UCS-4<a id="id2906571" class="indexterm"></a>或UTF-32<a id="id2906578" class="indexterm"></a>，UTF是Unicode Transformation Format<a id="id2906586" class="indexterm"></a>的縮寫。一方面這樣比較浪費存儲空間，由於常用字符都集中在BMP，高位的兩個字節通常是0，如果只用ASCII碼或Latin-1，高位的三個字節都是0。另一種比較節省存儲空間的辦法是用兩個字節表示一個字符，稱為UCS-2<a id="id2906598" class="indexterm"></a>或UTF-16<a id="id2906605" class="indexterm"></a>，這樣只能表示BMP中的字符，但BMP中有一些擴展字符，可以用兩個這樣的擴展字符表示其它平面的字符，稱為Surrogate Pair<a id="id2906615" class="indexterm"></a>。無論是UTF-32還是UTF-16都有一個更嚴重的問題是和C語言不兼容，在C語言中0字節表示字符串結尾，庫函數<code class="literal">strlen</code>、<code class="literal">strcpy</code>等等都依賴於這一點，如果字符串用UTF-32存儲，其中有很多0字節並不表示字符串結尾，這就亂套了。</p><p>UNIX之父Ken Thompson提出的UTF-8<a id="id2906642" class="indexterm"></a>編碼很好地解決了這些問題，現在得到廣泛應用。UTF-8具有以下性質：</p><div class="itemizedlist"><ul type="disc"><li><p>編碼為U+0000~U+007F的字符只佔一個字節，就是0x00~0x7F，和ASCII碼兼容。</p></li><li><p>編碼大於U+007F的字符用2~6個字節表示，每個字節的最高位都是1，而ASCII碼的最高位都是0，因此非ASCII碼字符的表示中不會出現ASCII碼字節（也就不會出現0字節）。</p></li><li><p>用於表示非ASCII碼字符的多字節序列中，第一個字節的取值範圍是0xC0~0xFD，根據它可以判斷後面有多少個字節也屬於當前字符的編碼。後面每個字節的取值範圍都是0x80~0xBF，見下面的詳細說明。</p></li><li><p>UCS定義的所有2<sup>31</sup>個字符都可以用UTF-8編碼表示出來。</p></li><li><p>UTF-8編碼最長6個字節，BMP字符的UTF-8編碼最長三個字節。</p></li><li><p>0xFE和0xFF這兩個字節在UTF-8編碼中不會出現。</p></li></ul></div><p>具體來說，UTF-8編碼有以下幾種格式：</p><div class="literallayout"><p>U-00000000 – U-0000007F: 	0xxxxxxx<br />
U-00000080 – U-000007FF: 	110xxxxx 10xxxxxx<br />
U-00000800 – U-0000FFFF: 	1110xxxx 10xxxxxx 10xxxxxx<br />
U-00010000 – U-001FFFFF: 	11110xxx 10xxxxxx 10xxxxxx 10xxxxxx<br />
U-00200000 – U-03FFFFFF: 	111110xx 10xxxxxx 10xxxxxx 10xxxxxx 10xxxxxx<br />
U-04000000 – U-7FFFFFFF: 	1111110x 10xxxxxx 10xxxxxx 10xxxxxx 10xxxxxx 10xxxxxx</p></div><p>第一個字節要麼最高位是0（ASCII字節），要麼最高兩位都是1，最高位之後1的個數決定後面有多少個字節也屬於當前字符編碼，例如111110xx，最高位之後還有四個1，表示後面有四個字節也屬於當前字符的編碼。後面每個字節的最高兩位都是10，可以和第一個字節區分開。這樣的設計有利於誤碼同步，例如在網絡傳輸過程中丟失了幾個字節，很容易判斷當前字符是不完整的，也很容易找到下一個字符從哪裡開始，結果頂多丟掉一兩個字符，而不會導致後面的編碼解釋全部混亂了。上面的格式中標為x的位就是UCS編碼，最後一種6字節的格式中x位有31個，可以表示31位的UCS編碼，UTF-8就像一列火車，第一個字節是車頭，後面每個字節是車廂，其中承載的貨物是UCS編碼。UTF-8規定承載的UCS編碼以大端表示，也就是說第一個字節中的x是UCS編碼的高位，後面字節中的x是UCS編碼的低位。</p><p>例如U+00A9（c字符）的二進制是10101001，編碼成UTF-8是11000010 10101001（0xC2 0xA9），但不能編碼成11100000 10000010 10101001，UTF-8規定每個字符只能用盡可能少的字節來編碼。</p></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="apas01.html" tppabs="http://resource.lancetw.org/ebook/linux-c-on-site-learning-zh-tw/apas01.html">上一頁</a> </td><td width="20%" align="center"><a accesskey="u" href="apa.html" tppabs="http://resource.lancetw.org/ebook/linux-c-on-site-learning-zh-tw/apa.html">上一級</a></td><td width="40%" align="right"> <a accesskey="n" href="apas03.html" tppabs="http://resource.lancetw.org/ebook/linux-c-on-site-learning-zh-tw/apas03.html">下一頁</a></td></tr><tr><td width="40%" align="left" valign="top">1. ASCII碼 </td><td width="20%" align="center"><a accesskey="h" href="index.html" tppabs="http://resource.lancetw.org/ebook/linux-c-on-site-learning-zh-tw/index.html">起始頁</a></td><td width="40%" align="right" valign="top"> 3. 在Linux C編程中使用Unicode和UTF-8</td></tr></table></div></body></html>
