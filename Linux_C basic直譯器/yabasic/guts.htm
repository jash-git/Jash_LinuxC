<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0//EN">
<html>
<head>
<title>Guide into the guts of Yabasic</title>
<link rel="stylesheet" type="text/css" href="standard.css" tppabs="http://www.yabasic.de/standard.css">
<meta name="author" content="Marc-Oliver Ihm">
<meta name="generator" content="Namo WebEditor v3.0">

<script language="JavaScript"><!--
if (top == self) window.location.href='default.htm'/*tpa=http://www.yabasic.de/default.htm*/;
//--></script>

</head>

<body bgcolor="white" text="black" link="blue" vlink="purple" alink="red">

<h1>Guide into the guts of Yabasic</h1>
<p>This document should serve as an introduction into the internals of yabasic. 
It is aimed at anyone who wants to: join the yabasic developer community OR 
modify yabasic for his or her own purposes OR learn how to build an interpreter.</p>
<p>Right now this document is just an small unstructured draft, but maybe, sometimes 
it will evolve into a large unstructured draft :-) But at least we have some 
Table of contents: 
<ul type="disc">
    <li><a href="#Tools">Tools needed to develop yabasic</a> 
    <li><a href="#Files of Yabasic">Files of Yabasic</a> 
    <li><a href="#Variables in yabasic">Variables in Yabasic</a> 
    <li><a href="#An example">An Example: Adding the foo$()-function</a> 
    <li><a href="# An second Example">An second Example: Adding the token()-function 
    </a>
</ul>
<h2><a name="Tools">Tools</a></h2>
<p>Lets make a list of tools needed to change or develop yabasic: 
<ul type="disc">
    <li>Linux or Windows 95/98/2000/NT ... 
    <li>gcc if you use Linux, Visual C++ 6.0 for Windows 
    <li><a href="#Flex and Bison">Flex and Bison</a> 
</ul>
<h2><a name="Flex and Bison">Flex and Bison</a></h2>
<p>Flex and Bison are tools which accept specially formatted input files (yabasic.flex 
and yabasic.bison) and emit C-code (flex.c and bison.c) which is compiled and 
linked to the rest of yabasic. Both are GNU tools and come with their own documentation 
in info format.</p>
<p>With Flex you can define the <b>tokens</b> of yabasic. Tokens are the keywords 
which constitute the skeleton of any yabasic program. &quot;if&quot;, &quot;print&quot;, 
&quot;&lt;&quot; are examples of tokens. If you'd like to change yabasic to 
accept &quot;whenever&quot; instead of &quot;if&quot;, you would need to tinker 
with the Flex input-file (which is named yabasic.flex). After that you could 
write &quot;whenever (a&lt;b) print a&quot; instead of &quot;if (a&lt;b) print 
a&quot; in yabasic.</p>
<p>The Bison input-file defines the <b>grammar</b> of yabasic. The grammar defines 
how tokens (acknowledged by Flex) must be arranged to yield a valid yabasic 
program. The grammar is a set of rules stating that &quot;if (a&lt;b) print 
a&quot; is a valid yabasic statement, but &quot;print a if (a&lt;b)&quot; is 
not. So if you think yabasic should understand &quot;print a if (a&lt;b)&quot; 
you should try to change yabasic.bison.</p>
<h2><a name="Files of Yabasic">Files of Yabasic</a></h2>
<p>To get a valid yabasic executable you need to compile and link seven C-files, 
which include two header-files; two of the C-files are generated by flex or 
bison. Here they are all lumped together: 
<ul type="disc">
    <li>yabasic.flex : input file to Flex, might be edited to add/change tokens. 
    Processing it with Flex produces: 
    <li>flex.c : produced by Flex, don't edit this file, rather change yabasic.flex 
    
    <li>yabasic.bison : input file to bison, might be edited to change the grammar. 
    Processing it with Bison produces: 
    <li>bison.c : produced by bison from yabasic.bison. 
    <li>io.c : code related with input/output, e.g. &quot;print&quot;, &quot;input&quot;. 
    
    <li>graphic.c : all about grafics and printing of grafics. 
    <li>main.c : main() function of yabasic, other stuff ... 
    <li>symbol.c : functions to create, store and retrieve symbols in yabasic. 
    
</ul>
<p>So lets have a close look at some of them:&nbsp;</p>
<p><i>To be continued ...</i></p>
<h2><a name="Variables in yabasic">Variables in yabasic</a></h2>
<p>Here are some remarks about how yabasic organises its variables.</p>
<h3>Overview</h3>
<p>Yabasic keeps lists of all its variables (e.g. foo, bar$ as well as arrays). 
There is one list for all variables used within the (main) program and one list 
for each subroutine. The variable list for a subroutines is created, as soon 
as yabasic starts executing a subroutine and it is removed as soon as the subroutine 
is left. There will be many lists a any given time, because one subroutine may 
call another (or even itself).</p>
<p>At the beginning of the execution of a program (or subroutine), the corresponding 
variable list is empty until any statement references a variable (e.g. a=2). 
In this moment yabasic searches the list for a variable named &quot;a&quot; 
and will not find id (as the list is empty initially). Instead of complaining, 
yabasic will just create the variable &quot;a&quot; (with an initial value of 
0).</p>
<p>Unfortunately this process of searching a variable within a list of variables 
is quite slow; to speed up things, yabasic remembers the location of each variable 
and stores it along with the command which references the variable. I.e. the 
internal representation of the command &quot;a=2&quot; would store not only 
the name of the variable &quot;a&quot;, but also the exact position of this 
variable within yabasic's list of variables. The next time this command is executed, 
the variable need not be searched again, and access is quite fast.</p>
<p>However, this scheme is not perfect: Consider a subroutine; as said before 
each subroutine has its own list of variables (which keeps the variables local 
to this subroutine and all parameters). Therefore, if yabasic needs to find 
a variable within a subroutine, it searches within the local list of variables 
(and adds it there if necessary). And again, the location of the variable is 
stored with the command to speed up the next access. Now if the subroutine is 
done the local list of variables is removed, and therefore all references to 
those variables have to be invalidated, because the variables which they refer 
to are gone. Next time the subroutine is called, each variable has to be searched 
(and maybe created) again. So there is some time overhead in calling subroutines 
from within yabasic; however, this overhead should generally be made up by the 
improvement in program logic and readbility which can be achieved by using subroutines.</p>
<h3>Routines and structures</h3>
<p>Handling of variables is so important that nearly the whole source file <b>symbol.c 
&nbsp;</b>deals with this topic; the relevant structures however are defined 
in <b>yabasic.h</b>:</p>
<p><b>struct symbol</b> is the C-structure, which may store any variable (=symbol): 
numbers, strings or arrays. It has room to store a double value as well as a 
pointer to a string or to the elements of an array (for any given symbol only 
one of those is actually used). Furthermore it has pointers to be kept in a 
list of symbols associated with the main program or a subroutine.</p>
<p><b>struct symstack</b> is used to keep the many lists of variables (=symbols), 
which might be active at any given time. Elements of type <b>struct symstack</b> 
form a linked list and each forms the head of a list of variables (elements 
of type struct symbol).</p>
<p>A list of variables is created by the function <b>pushsymlist()</b>; as soon 
as the subroutine to which the list belongs is done, the list is removed by 
<b>popsymlist()</b>. popsymlist() calls <b>freesym()</b> fro each symbol to 
free any memory associated with this symbol. The most important function however 
is <b>get_sym()</b> which searches the different lists of variables and searches 
for a named symbol; if the symbol is not found it might be created. The detailed 
behaviour of get_sym() is defined by the parameter <b>add</b>, which is of type 
<b>addmodes</b> (as defined in yabasic.h). It specifies, if an unknown symbol 
should be added, or an error should be returned; and if an unknown symbol is 
added, it might be added as a local or a global variable depending on the value 
of <b>add</b>.</p>
<h2><a name="An example">An example: Adding the foo$() function</a></h2>
<p>In this example we will learn the steps necessary to add a new function to 
yabasic. The function foo$() serves as an example: It takes a single numeric 
argument and returns a string consisting of as many repetitions of the string 
&quot;foo&quot; as specified in the argument; i.e. foo$(2) would return &quot;foofoo&quot;, 
which is quite silly but enough to learn the necessary steps.</p>
<p>Yabasic already has quite a bunch of functions so we may follow the path 
of some existing function, when adding our new function foo$(). A suitable function 
would be str$(), which takes a numeric argument and returns a string just as 
our prospected function foo$().</p>
<p>Assuming, that you are using linux (or some other Unix), do the following: 

<ul type="disc">
    <li>Edit the file &quot;yabasic.flex&quot; ; add the line 
    <pre>&nbsp;&quot;FOO$&quot; return tFOO;</pre>
    <li>You may not add this line anywhere; &quot;yabasic.flex&quot; consists 
    of several regions and you have to add this line to the right region: Just 
    search for tSTR to find the place where the str$()-function is defined; 
    foo$() may be defined there too.<br> The new line advises the flex-tokenizer 
    (the C-File generated by flex) to return the integer constant tFOO , whenever 
    it finds the string &quot;FOO$&quot;. 
    <li>The integer constant tFOO has been used above but not defined yet ! 
    To do this, edit the file &quot;yabasic.bison&quot;: Search for the region 
    of lines starting with &quot;%token&quot; and add to one of these lines 
    &quot;tFOO&quot; (again you may seek the proximity of tSTR, for consistency). 
    
    <li>Still in file &quot;yabasic.bison&quot; search the region where string 
    functions are defined: search for &quot;string_function:&quot; and add this 
    line: 
    <pre>| tFOO '(' expression ')' {create_function(fFOO);}</pre>
    <li>This line says, that a string_function (apart from the alternatives 
    defined in the surrounding lines) may start with the token tFOO followed 
    by a (numerical) expression in round braces. If a yabasic program contains 
    this new function foo$(), the code in curly braces ( create_function(fFOO); 
    ) will be executed. These are all changes necessary for &quot;yabasic.bison&quot; 
    . 
    <li>The line above contained the constant fFOO which is not yet defined; 
    open &quot;yabasic.h&quot; and search for the string &quot;enum functions&quot;. 
    This enumeration defines all the functions known to yabasic, so you have 
    to add fFOO here. Note, that there are special entries fZEROARGS, fONEARG, 
    fTWOARGS, ... as our function fFOO accepts just a single argument, we have 
    to add fFOO between fZEROARGS and fONEARG ; we may add fFOO just behind 
    fSTR as both functions accept a single argument. That's all there is to 
    &quot;yabasic.h&quot; 
    <li>Now we have added almost everything but the code which actually performs 
    the work. Functions are defined in the file (surprise !) function.c . Open 
    this file and go to the function &quot;function()&quot; . function() consists 
    mostly of a large switch-block, where we have to add a case statement for 
    out foo()-function. A possible implementation would be: 
    <pre>case fFOO:<br>
 pointer=my_foo((int) a1-&gt;value);
 result=stSTRING;
 break;</pre>
    <li>Most of the work is done in the function my_foo() (see below for a possible 
    definition). The argument which has been passed to fFOO is available through 
    the pointer a1, which points to a structure of type &quot;struct stackentry&quot; 
    (further arguments would be in a2, a3). If the argument passed to foo() 
    is a numeric value, this value is contained in a1-&gt;value (a string value 
    would be in a1-&gt;pointer). So we just have to pass a1-&gt;value to my_foo(), 
    which does the real work. my_foo() returns a pointer to a string, which 
    we save in the variable &quot;pointer&quot; ; moreover we remember its type 
    as stSTRING (the enumeration &quot;enum stackentries&quot; in yabasic.h 
    defines the types of values which may be pushed onto the internal stack). 
    That's all and so we break out of the switch statement. Now we just have 
    to add the function my_foo() to function.c: 
    <pre>char *my_foo(int mult) {
 char *res;
 if (mult&lt;0) {
  error(ERROR,&quot;negative values not allowed for function foo()&quot;); 
  return my_strdup(&quot;&quot;); 
 } 
 res=my_malloc(mult*4+1); 
 res[0]='\0'; 
 for(i=0;i&lt;mult;i++) strcat(res,&quot;foo&quot;) 
 return res;
}</pre>
    <li>The prototype for this function can be added at the top of function.h 
    (after the comment /* -------- local functions ---------*/): 
    <pre>char *my_foo(int);</pre>
    <li>A few words regarding the implementation of the function foo():<br> 
    
    <ul type="disc">
        <li>error() is the standard function used to report an ERROR, a WARNING,NOTE 
        or FATAL. 
        <li>my_malloc() is just a wrapper around the usual malloc(), which returns 
        a pointer to the requested memory area. If no more memory can be allocated, 
        a FATAL is issued, and the function does not return at all. Therefore 
        it is not necessary to check for the return value of my_malloc(). 
    </ul>
    <li>Now you just have to put it all together, use make to process all the 
    changed files: 
    <pre>make flex
make bison
make&nbsp;</pre>
</ul>
<p>That's it ! Now all files are up to date. The new built of yabasic knows 
about the foo$()-function and is ready for extensive testing :-) </p>
<h1><a name=" An second Example">&nbsp;An second Example: Adding the token()-function 
</a></h1>
<p>This example is considerably shorter than the <a href="#An example">first 
one</a>, which you should have read in advance. Here you see how to implement 
the token()-function, which is already present in yabasic, so you may have a 
look at the sources for any details. You may use the token()-function like this:</p>
<ul>
    <pre>dim w$(1)<br>
n=split(&quot;one::two:thre::four&quot;,w$(),&quot;:&quot;)
print n</pre>
</ul>
<p>The array-parameter is the most interesting thing about the token()-function, 
so we will see how it is handled. The definitions in &quot;yabasic.flex&quot; 
are quite standard: see the first example for details about the necessary modifications. 
Therefore we will have a look at the definition in &quot;yabasic.bison&quot;:</p>
<ul>
    <pre>&nbsp;&nbsp;| tTOKEN '(' string_expression ',' string_arrayref ',' string_expression ')' {add_command(cTOKEN2,NULL);}
&nbsp;&nbsp;| tTOKEN '(' string_expression string_arrayref ',' ')' {add_command(cTOKEN,NULL);}
&nbsp;&nbsp;| tSPLIT '(' string_expression ',' string_arrayref ',' string_expression ')' {add_command(cSPLIT2,NULL);}
&nbsp;&nbsp;| tSPLIT '(' string_expression string_arrayref ',' ')' {add_command(cSPLIT,NULL);}
&nbsp;&nbsp;</pre>
</ul>
<p>Note that token() and split() are defined twice, because each comes in two 
variants: With either two or three parameters (e.g. token(&quot;one::two&quot;,a$()) 
and token(&quot;one::two&quot;,a$(),&quot;:&quot;) ). These lines extend the 
definition of a yabasic-function (search for the string &quot;function:&quot;). 
All functions in yabasic are defined in the same region of the &quot;yabasic.bison&quot;. 
Most of these lines contain a create_function()-statement (e.g. create_function(fSIN) 
): This is the easiest way to define a function in yabasic (as you may see in 
the <a href="#An example">first example</a>). However, token() and split() require 
a reference to an array among their arguments, which is uncommon for yabasic-functions, 
and therefore special commands (cTOKEN, cTOKEN2, cSPLIT, cSPLIT2) have been 
added. These commands then have to handle the array reference which is passed 
on the stack of yabasic. But before examining those functions more closely, 
we have to check the definition of string_arrayref, which appears in the lines 
above. Within &quot;yabasic.bison&quot; you will find:</p>
<ul>
    <pre>string_arrayref: tSTRSYM '(' ')' {create_pusharrayref(dotify($1,FALSE),stSTRINGARRAYREF);}</pre>
</ul>
<p>This tells us, that an array reference is just a string symbol (e.g. foo$) 
followed by a pair of braces, i.e. something like foo$() . If such an array 
reference is found, the create_pusharrayref() is called; it is defined in symbol.c:</p>
<ul>
    <pre>void create_pusharrayref(char *name,int type) /* create command 'cPUSHARRAYREF' */<br>
{<br>
&nbsp;&nbsp;struct command *cmd;
&nbsp;&nbsp;cmd=add_command(cPUSHARRAYREF,name);
&nbsp;&nbsp;cmd-&gt;args=type;
}
&nbsp;
void pusharrayref(struct command *cmd) /* push an array reference onto stack */
{
&nbsp;&nbsp;struct stackentry *s;
&nbsp;&nbsp;s=push();
&nbsp;&nbsp;s-&gt;type=cmd-&gt;args;
&nbsp;&nbsp;s-&gt;pointer=my_strdup(cmd-&gt;name);
}</pre>
</ul>
<pre>&nbsp;
create_pusharrayref() does nothing special, it just calls add_command() and 
stores the name of the array (e.g. foo$() ) reference and its expected type 
(reference to a numeric or a string array). create_pusharrayref() is called 
during parsing/compilation of the yabasic-program, wheras pusharrayref() is 
called during execution (you may search in &quot;main.c&quot; for &quot;pusharrayref()&quot; 
to see how it is called). pusharrayref() is quite trivial: It just takes the 
name of the array (e.g. foo$() ) and pushes it onto the yabasic stack, where 
it is ready to be used by token(). Lets look at some of the code defined in 
&quot;function.c&quot;:
&nbsp;</pre>
<ul>
    <pre>&nbsp;
    
void token(struct command *cmd) /* extract token from variable */
{
&nbsp;&nbsp;int split;
&nbsp;&nbsp;struct stackentry *s;
&nbsp;&nbsp;struct symbol *sym;
&nbsp;&nbsp;struct array *ar;                <i>..... some definitions omitted .....</i>
&nbsp;&nbsp;int num=0,i;
&nbsp;&nbsp;char *del,*line;
&nbsp;&nbsp;
&nbsp;&nbsp;if (cmd-&gt;type==cSPLIT2 || cmd-&gt;type==cTOKEN2)
&nbsp;&nbsp;&nbsp;&nbsp;del=pop(stSTRING)-&gt;pointer;
&nbsp;&nbsp;else
&nbsp;&nbsp;&nbsp;&nbsp;del=&quot; \t&quot;;                                     
<i>..... one line omitted .....</i>
&nbsp;&nbsp;s=pop(stSTRINGARRAYREF);
&nbsp;&nbsp;line=pop(stSTRING)-&gt;pointer;
&nbsp;&nbsp;sym=get_sym(s-&gt;pointer,syARRAY,amSEARCH);
&nbsp;&nbsp;if (!sym || !sym-&gt;pointer) {
&nbsp;&nbsp;&nbsp;&nbsp;sprintf(string,&quot;array '%s()' is not defined&quot;,strip(s-&gt;pointer));
&nbsp;&nbsp;&nbsp;&nbsp;error(ERROR,string);
&nbsp;&nbsp;&nbsp;&nbsp;goto token_done;
&nbsp;&nbsp;}
&nbsp;&nbsp;ar=sym-&gt;pointer;
&nbsp;&nbsp;if (ar-&gt;dimension&gt;1) {
&nbsp;&nbsp;&nbsp;&nbsp;error(ERROR,&quot;only one dimensional arrays allowed&quot;);
&nbsp;&nbsp;&nbsp;&nbsp;goto token_done;
&nbsp;&nbsp;}
&nbsp;
                   ..... Many lines omitted .....
&nbsp;
 token_done:     
&nbsp; s=push();
&nbsp; s-&gt;type=stNUMBER;
&nbsp; s-&gt;value=num;
}</pre>
</ul>
<p>Depending on the command (cTOKEN, cTOKEN2, cSPLIT or cSPLIT2) there are two 
or three parameters on the stack ( token(&quot;one::two&quot;,a$()) and token(&quot;one::two&quot;,a$(),&quot;:&quot;) 
both are valid ); therefore the string with delimiters (&quot;del&quot;) is 
either popped from the stack or preset with a default value (&quot; \t&quot;). 
</p>
<p>Next (and more interesting) an element of type stSTRINGARRAYREF is popped 
from the stack; this is just the name of the array (e.g. foo$() ), which has 
been pushed onto the stack before within pusharrayref() . The next step is to 
get the symbol which represents the array (see <a href="#Variables in yabasic">above</a> 
for details on variables and symbols); this is done with get_sym(), which returns 
a pointer sym to a symbol structure (as defined in yabasic.h). If get_sym() 
returns NULL, the array (e.g. foo$() ) has not been defined. The symbol sym 
in turn contains a multi-purpose pointer (sym-&gt;pointer) which points to an 
array structure (as defined in yabasic.h). This pointer is assigned to the variable 
ar.</p>
<p>Now everything is prepared to do real work: A first step is to check, if 
the array, which has been passed is a one-dimensional array as expected. The 
next few lines of the token()-function are omitted: They split the string (pointed 
to by the variable line) into tokens and calculate the number of tokens within 
the variable num. This number is the result of the yabasic-function token() 
and is finally pushed onto the stack.</p>
</body>

</html>